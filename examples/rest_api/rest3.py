"""
Simple REST API for CRUD operations, when identity is Mongo's ObjectId and is part of database model.

Actually it's a most complicated scenario, there are many subtle points in this matter (see link below),
and all those points are out of scope of PyMotyc, which is only manages app<->database communication,
while serialization of the model for network communication is not part of it, so we do it by hands,
converting database model to network one and vise versa.

For that reason, it is much much easier to use str representation of uuid, generated by PyMotyc
as resource id, which is covered in rest.py and is a recommended way to use pymotyc.

https://github.com/tiangolo/fastapi/issues/1515
"""
from typing import List

from bson import ObjectId
from fastapi import FastAPI, Query
from motor.motor_asyncio import AsyncIOMotorClient
from pydantic import BaseModel, parse_obj_as, parse_raw_as
from pymongo.errors import DuplicateKeyError
from starlette.responses import JSONResponse
from starlette.testclient import TestClient

import pymotyc


# ----------------------------------------------------

class EmployeeIn(BaseModel):
    full_name: str
    age: int


class EmployeeOut(EmployeeIn):
    id: str


class Employee(EmployeeIn, pymotyc.WithId):
    pass


# ----------------------------------------------------

engine = pymotyc.Engine()


@engine.database
class Warehouse:
    employees: pymotyc.Collection[Employee]


# ----------------------------------------------------

app = FastAPI(
    title='Warehouse',
    description='Simple Warehouse CRUD service for Employees, engine-managed identity.',
    version="0.1.0",
)


@app.on_event("startup")
async def init_app():
    motor = AsyncIOMotorClient("mongodb://127.0.0.1:27017")
    await engine.bind(motor=motor, inject_motyc_fields=True)
    await Warehouse.employees.collection.drop()
    await Warehouse.employees.create_indexes()


# ----------------------------------------------------

@app.exception_handler(pymotyc.errors.NotFound)
async def not_found(_request, exc):
    return JSONResponse({"detail": str(exc)}, status_code=404)


@app.exception_handler(DuplicateKeyError)
async def exists_or_constrain_violation(_request, exc):
    return JSONResponse({"detail": str(exc)}, status_code=400)


# ----------------------------------------------------

@app.post('/employees', response_model=EmployeeOut, status_code=201)
async def create_employee(employee: EmployeeIn) -> EmployeeOut:
    """ Creates employee in database, id field should be empty. """

    # There are couple of tricks.

    # Remember both In and database models can be discriminated unions,
    # so we use parse_obj_as (not Employee.parse_obj) to convert EmployeeIn
    # to database model Employee (with empty id) and then save it to obtain id.
    employee = await Warehouse.employees.save(parse_obj_as(Employee, employee))

    # Then we have to convert database model Employee to network model EmployeeOut.
    # Fot that, first we use employee.json() to serialize database model,
    # ObjectId will be converted to str thanks to json serializer, configured in MotycModel.
    # Note, we are not using .json(by_alias = True), so id field will keep it's
    # model name 'id', not document name '_id', as required for EmployeeOut.
    # Then we use parse_raw_as, to construct network model EmployeeOut.
    # Of cause this is just one approach (slow one btw) to serialize database model,
    # but again - it's not a topic of PyMotyc, we propose to use it with
    # generated uuids as resource id.
    return parse_raw_as(EmployeeOut, employee.json())


@app.get('/employees', response_model=List[EmployeeOut])
async def list_employees() -> List[EmployeeOut]:
    """ Returns employees list from database ordered by name. """
    return [
        parse_raw_as(EmployeeOut, employee.json())
        for employee in await Warehouse.employees.find(sort={Employee.full_name: 1})
    ]


@app.get('/employees/{_id}', response_model=EmployeeOut)
async def get_employee(_id: str) -> EmployeeOut:
    """ Returns employee from database by it's id. """
    employee = await Warehouse.employees.find_one({Employee.id: ObjectId(_id)})
    return parse_raw_as(EmployeeOut, employee.json())


@app.put('/employees/{_id}', response_model=EmployeeOut)
async def put_employee(_id: str, employee: EmployeeIn) -> EmployeeOut:
    """ Updates employee completely in database by given id."""
    employee = parse_obj_as(Employee, employee)
    employee.id = ObjectId(_id)
    employee = await Warehouse.employees.save(employee, mode='update')
    return parse_raw_as(EmployeeOut, employee.json())


@app.patch('/employees/{_id}', response_model=EmployeeOut)
async def patch_employee(_id: str, inc_age: int = Query(1)) -> EmployeeOut:
    """ Increments employee's age by given id. """

    employee = await Warehouse.employees.update_one(
        {Employee.id: ObjectId(_id)},
        update={'$inc': {Employee.age: inc_age}}
    )
    return parse_raw_as(EmployeeOut, employee.json())


@app.delete('/employees/{_id}', status_code=204)
async def delete_employee(_id: str):
    """ Delete employee with given login from database. """
    await Warehouse.employees.delete_one({Employee.id: ObjectId(_id)})


if __name__ == "__main__":
    with TestClient(app) as cli:
        response = cli.post('/employees', json={'full_name': 'Vasya Pupkin', 'age': 42})
        assert response.status_code == 201
        vasya = response.json()
        vasya_id = vasya['id']
        assert ObjectId(vasya_id)  # Vasya's id is ObjectId generated by Mongo in str representation.
        assert vasya == {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 42}

        response = cli.post('/employees', json={'full_name': 'Frosya Taburetkina', 'age': 20})
        assert response.status_code == 201
        frosya_id = response.json()['id']

        response = cli.get('/employees')
        assert response.status_code == 200
        assert response.json() == [
            {'id': frosya_id, 'full_name': 'Frosya Taburetkina', 'age': 20},
            {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 42}
        ]

        response = cli.get('/employees/' + vasya_id)
        assert response.status_code == 200
        assert response.json() == {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 42}

        response = cli.put('/employees/' + vasya_id, json={'full_name': 'Vasya Pupkin', 'age': 43})
        assert response.status_code == 200
        assert response.json() == {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 43}

        response = cli.get('/employees/' + vasya_id)
        assert response.status_code == 200
        assert response.json() == {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 43}

        response = cli.get('/employees/' + str(ObjectId()))
        assert response.status_code == 404

        response = cli.put('/employees/' + str(ObjectId()), json={'full_name': 'Dusya Ivanova', 'age': 22})
        assert response.status_code == 404

        response = cli.delete('/employees/' + frosya_id)
        assert response.status_code == 204

        response = cli.delete('/employees/' + frosya_id)
        assert response.status_code == 404

        response = cli.get('/employees')
        assert response.status_code == 200
        assert response.json() == [
            {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 43}
        ]

        response = cli.patch('/employees/' + vasya_id + '?inc_age=2')
        assert response.status_code == 200
        assert response.json() == {'id': vasya_id, 'full_name': 'Vasya Pupkin', 'age': 45}

        response = cli.patch('/employees/' + str(ObjectId()) + '?inc_age=2')
        assert response.status_code == 404
