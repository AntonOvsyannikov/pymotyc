import asyncio
from typing import Union
from uuid import uuid4

from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorClient
from typing_extensions import Literal

# import like this
from pymotyc import M, MotycModel, Engine, Collection


# ====================================================

class Employee(MotycModel):
    name: str
    age: int


class ProductBase(MotycModel):
    kind: str
    product_id: str = None


class Book(ProductBase):
    kind: Literal['book'] = 'book'
    title: str
    pages: int


class Computer(ProductBase):
    kind: Literal['computer'] = 'computer'
    vendor: str


Product = Union[Book, Computer]

# ====================================================

engine = Engine()


@engine.database
class Warehouse:
    employees: Collection[Employee]
    products: Collection[Product] = Collection(
        indexes=['kind'],
        identity='product_id',
        id_generator=lambda: str(uuid4())
    )


async def main():
    motor = AsyncIOMotorClient("mongodb://127.0.0.1:27017")

    # We want to use refactorable queues, so use inject_motyc_fields=True
    await engine.bind(motor=motor, inject_motyc_fields=True)

    await Warehouse.employees.collection.drop()
    await Warehouse.products.collection.drop()
    await Warehouse.products.create_indexes()

    # ====================================================
    # Use statically typed collections - employees
    # ====================================================

    # Let add several Employee to the collection.
    await Warehouse.employees.save(Employee(name='Vasya Pupkin', age=42))

    # Let find one by age to modify, no need to inject _id field, we have id in MotycModel.
    # Unfortunately Pydantic has no ablility to use underscored _id attribute directly in the model,
    # only through aliases, so it's mapped to 'id' field (see MotycModel).
    employee = await Warehouse.employees.find_one({Employee.name: 'Vasya Pupkin'})
    assert hasattr(employee, 'id')
    assert isinstance(employee.id, ObjectId)

    # Let modify returned object and save it to bound collection, it was retrived from.
    # To use this feature, Model should be inherited from MotycModel, otherwise use Collection.save.
    employee.age = 43
    await employee.save()

    # Also we can manipulate model returned by save directly, it already have id of saved object
    employee = await Warehouse.employees.save(Employee(name='Frosya Taburetkina', age=21))
    employee.age += 1
    await employee.save()
    assert (await Warehouse.employees.find_one({Employee.name: 'Frosya Taburetkina'})).age == 22

    # We can also use simple query builder, built in PyMotyc
    employees = await Warehouse.employees.find(M(Employee.name).regex("Vasya") & (M(Employee.age) < 50))
    assert len(employees) == 1, len(employees)
    assert employees[0].name == 'Vasya Pupkin'
    assert employees[0].age == 43

    # ====================================================
    # Use statically typed collections - products
    # ====================================================

    # Let add several products of different kinds to the collection.
    await Warehouse.products.save(Book(title='Hamlet', pages=42))
    await Warehouse.products.save(Book(title='Hello', pages=10))
    await Warehouse.products.save(Computer(vendor='apple'))
    await Warehouse.products.save(Computer(vendor='hp'))

    # Let find one and explore it's identity
    product = await Warehouse.products.find_one((M(ProductBase.kind) == 'book') & (M(Book.title) == 'Hamlet'))
    assert product.kind == 'book'
    assert product.product_id  # UUID generated while saving with collection id generator
    assert isinstance(product.id, ObjectId)  # _id generated by Mongo, it will be ignored in next save
    print(product)  # let even print to explore

    # Let find computers
    products = await Warehouse.products.find({ProductBase.kind: 'computer'})
    assert len(products) == 2
    for product in products: assert isinstance(product, Computer)
    assert {p.vendor for p in products} == {'apple', 'hp'}

    print("Everything fine!")


if __name__ == "__main__":
    asyncio.run(main())
